<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конвертер та Менеджер Документів</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- JSZip for ZIP file creation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <!-- jsPDF for Image to PDF conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- pdf-lib for merging PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.js"></script>
    <!-- pdf.js (Mozilla) for robust PDF viewing in Canvas (main script) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

    <style>
        /* Стилі для body та шрифтів */
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        
        /* Стилі для зони перетягування */
        .drop-zone {
            border: 2px dashed #a0a0a0;
            border-radius: 12px;
            transition: all 0.2s;
        }
        .drop-zone.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        
        /* Стилі для полів прив'язки */
        .field-zone {
            border: 2px dashed #d1d5db;
            transition: all 0.2s;
        }
        .field-zone.has-file {
            border-style: solid;
            border-color: #10b981;
            background-color: #ecfdf5;
        }
        
        /* Кастомний скролбар для попереднього перегляду */
        .scrollable-preview::-webkit-scrollbar { width: 6px; }
        .scrollable-preview::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .scrollable-preview::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        .scrollable-preview::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Стилі для PDF сторінок у модальному вікні */
        #previewContent canvas {
            max-width: 100%; /* Гарантуємо, що Canvas не вийде за межі контейнера */
            height: auto;
        }
    </style>
</head>
<body>

<div id="app" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
    
    <header class="mb-8">
        <h1 class="text-3xl font-bold text-gray-800">Конвертер та Менеджер Документів (PDF 2.0)</h1>
        <p class="text-gray-500">Завантажте, об'єднайте та організуйте файли для формування пакету.</p>
    </header>

    <!-- Internal Code Input and Controls -->
    <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
        <div class="flex flex-col md:flex-row md:items-end md:space-x-4 space-y-4 md:space-y-0">
            <div class="flex-grow">
                <label for="internalCode" class="block text-sm font-medium text-gray-700">Внутрішній код (Обов'язково для назви файлів)</label>
                <input type="text" id="internalCode" placeholder="Наприклад: PROD-2024-001" 
                        class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-3 border"
                        oninput="updateDownloadButtonState()">
            </div>
            
            <button onclick="handleZipDownload()" id="downloadZipBtn" 
                    class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 disabled:opacity-50" disabled>
                <span id="downloadText">Завантажити ZIP</span>
            </button>
            
            <button onclick="handleClearAll()" 
                    class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150">
                Очистити все
            </button>
        </div>
    </div>

    <!-- File Upload Zone -->
    <div id="dropZone" class="drop-zone p-10 text-center cursor-pointer mb-8"
            onclick="document.getElementById('fileInput').click()"
            ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
        <svg class="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
        </svg>
        <p class="mt-1 text-sm text-gray-600">Перетягніть файли сюди або <span class="text-blue-600 font-semibold">натисніть для вибору</span></p>
        <p class="text-xs text-gray-500">Підтримуються: .jpg, .png, .pdf, .doc, .docx та інші.</p>
        <input type="file" id="fileInput" multiple accept="*/*" onchange="handleFileUpload(this.files)" class="hidden">
    </div>

    <!-- Main Content Area: Files and Fields -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

        <!-- 1. Uploaded Files List -->
        <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">Завантажені файли (<span id="fileCount">0</span>)</h2>
            
            <!-- Merge Controls -->
            <div id="mergeControls" class="flex flex-col sm:flex-row sm:items-center sm:space-x-4 space-y-2 sm:space-y-0 mb-4">
                <div id="imageMergeControls" class="flex items-center space-x-2" style="display:none;">
                    <button onclick="handleImageMerge()" class="bg-orange-500 hover:bg-orange-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 disabled:opacity-50" id="imageMergeBtn" disabled>
                        Об'єднати зображення у PDF
                    </button>
                    <!-- Оновлена підказка для 1+ файлів -->
                    <span class="text-xs text-gray-500">(Виберіть 1+ зображення)</span>
                </div>

                <div id="pdfMergeControls" class="flex items-center space-x-2" style="display:none;">
                    <button onclick="handlePdfMerge()" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 disabled:opacity-50" id="pdfMergeBtn" disabled>
                        Об'єднати PDF-файли
                    </button>
                    <span class="text-xs text-gray-500">(Виберіть 2+ PDF)</span>
                </div>
            </div>
            
            <div id="fileList" class="min-h-[200px] border border-gray-200 rounded-lg p-3 scrollable-preview max-h-[60vh] overflow-y-auto space-y-2">
                <p id="emptyMessage" class="text-gray-400 text-center py-10">Файли ще не завантажені.</p>
            </div>
        </div>

        <!-- 2. Binding Fields -->
        <div class="bg-white p-6 rounded-xl shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">Прив'язка до полів</h2>
            <div id="bindingFields" class="space-y-4">
                <!-- Field 1: Instruction -->
                <div id="field_manual" data-key="manual" data-label="Інструкція" 
                    class="field-zone p-4 rounded-lg min-h-[100px]"
                    ondragover="handleFieldDragOver(event)" ondragleave="handleFieldDragLeave(event)" ondrop="handleFieldDrop(event)">
                    <p class="font-medium text-gray-700 flex justify-between items-center">
                        Інструкція <span id="manualFileName" class="text-sm font-normal text-green-700"></span>
                    </p>
                    <p class="text-sm text-gray-500 mt-1">Перетягніть файл інструкції сюди.</p>
                    <button id="manualRemoveBtn" onclick="removeBoundFile('manual')" class="text-red-500 text-xs hidden mt-2 hover:text-red-700">Видалити прив'язку</button>
                </div>

                <!-- Field 2: Technical Specifications -->
                <div id="field_specs" data-key="specs" data-label="Технічні характеристики" 
                    class="field-zone p-4 rounded-lg min-h-[100px]"
                    ondragover="handleFieldDragOver(event)" ondragleave="handleFieldDragLeave(event)" ondrop="handleFieldDrop(event)">
                    <p class="font-medium text-gray-700 flex justify-between items-center">
                        Технічні характеристики <span id="specsFileName" class="text-sm font-normal text-green-700"></span>
                    </p>
                    <p class="text-sm text-gray-500 mt-1">Перетягніть файл тех. характеристик сюди.</p>
                    <button id="specsRemoveBtn" onclick="removeBoundFile('specs')" class="text-red-500 text-xs hidden mt-2 hover:text-red-700">Видалити прив'язку</button>
                </div>

                <!-- Field 3: Certificate -->
                <div id="field_certificate" data-key="certificate" data-label="Сертифікат" 
                    class="field-zone p-4 rounded-lg min-h-[100px]"
                    ondragover="handleFieldDragOver(event)" ondragleave="handleFieldDragLeave(event)" ondrop="handleFieldDrop(event)">
                    <p class="font-medium text-gray-700 flex justify-between items-center">
                        Сертифікат <span id="certificateFileName" class="text-sm font-normal text-green-700"></span>
                    </p>
                    <p class="text-sm text-gray-500 mt-1">Перетягніть файл сертифікату сюди.</p>
                    <button id="certificateRemoveBtn" onclick="removeBoundFile('certificate')" class="text-red-500 text-xs hidden mt-2 hover:text-red-700">Видалити прив'язку</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal for Large Preview -->
<div id="previewModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50" onclick="closePreviewModal()">
    <div class="bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden" onclick="event.stopPropagation()">
        <div class="flex justify-between items-center border-b p-4">
            <h3 id="previewTitle" class="text-lg font-semibold text-gray-800">Попередній перегляд</h3>
            <button onclick="closePreviewModal()" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <!-- Max height for scrollable content. Changed items-center to flex-col items-center for better scroll control -->
        <div id="previewContent" class="p-4 max-h-[80vh] overflow-y-auto flex flex-col items-center"> 
            <!-- Content (Image, Canvas, or Message) will be loaded here -->
        </div>
    </div>
</div>

<!-- Custom Message Box -->
<div id="messageBox" class="fixed bottom-4 right-4 bg-gray-800 text-white p-4 rounded-xl shadow-xl z-[100] transition-opacity duration-300 hidden opacity-0" role="alert">
    <p id="messageText"></p>
</div>


<script>
    // --- STATE MANAGEMENT ---
    let uploadedFiles = [];
    // { 'manual': fileId, 'specs': fileId, 'certificate': fileId }
    let boundFiles = {}; 
    let nextFileId = 1;
    
    // Global references
    const fileListEl = document.getElementById('fileList');
    const dropZoneEl = document.getElementById('dropZone');
    const downloadZipBtn = document.getElementById('downloadZipBtn');
    const imageMergeControlsEl = document.getElementById('imageMergeControls');
    const pdfMergeControlsEl = document.getElementById('pdfMergeControls');
    const previewModalEl = document.getElementById('previewModal');

    // Встановлення workerSrc для pdf.js (Обов'язково для роботи бібліотеки)
    if (window.pdfjsLib) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    }


    // --- UTILITIES ---

    /**
     * Відображає кастомне повідомлення (замість alert/confirm).
     * @param {string} text - Текст повідомлення.
     * @param {number} [duration=3000] - Тривалість відображення в мс.
     */
    function showMessage(text, duration = 3000) {
        const box = document.getElementById('messageBox');
        const textEl = document.getElementById('messageText');
        
        textEl.textContent = text;
        box.classList.remove('hidden');
        setTimeout(() => box.classList.remove('opacity-0'), 10); // Start fade-in
        
        setTimeout(() => {
            box.classList.add('opacity-0');
            setTimeout(() => box.classList.add('hidden'), 300); // Wait for fade-out before hiding
        }, duration);
    }
    
    /**
     * Генерує простий SVG-значок на основі MIME-типу файлу.
     * @param {string} mimeType - MIME-тип файлу.
     * @returns {string} - HTML-рядок з SVG-значком.
     */
    function getFileIcon(mimeType) {
        const baseClass = "w-8 h-8";
        if (mimeType.startsWith('image/')) return `<svg class="${baseClass} text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>`;
        
        // Оновлена іконка для PDF (Згідно з запитом 3)
        if (mimeType === 'application/pdf') return `<svg class="${baseClass} text-red-600" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H8c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 15h-2v-2h2v2zm0-4h-2V9h-2V7h4v6zm-4-10H8v16h8V8l-4-4z"/></svg>`;
        
        // SVG для Word/Office
        if (mimeType.includes('officedocument') || mimeType.includes('word')) return `<svg class="${baseClass} text-blue-500" fill="currentColor" viewBox="0 0 24 24"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1s-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm1 14H8v-2h5v2zm3-4H8v-2h8v2zm0-4H8V7h8v2z"></path></svg>`;
        // SVG для іншого
        return `<svg class="${baseClass} text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>`;
    }

    /**
     * Перевіряє, чи є файл зображенням
     * @param {Object} fileObject - Об'єкт файлу з масиву uploadedFiles.
     * @returns {boolean}
     */
    function isImage(fileObject) {
        return fileObject.type.startsWith('image/');
    }

    /**
     * Перевіряє, чи є файл PDF
     * @param {Object} fileObject - Об'єкт файлу з масиву uploadedFiles.
     * @returns {boolean}
     */
    function isPdf(fileObject) {
        return fileObject.type === 'application/pdf';
    }
    
    /**
     * Оновлює стан кнопки Завантажити ZIP
     */
    function updateDownloadButtonState() {
        const code = document.getElementById('internalCode').value.trim();
        const hasBoundFiles = Object.keys(boundFiles).some(key => boundFiles[key]);
        downloadZipBtn.disabled = !code || !hasBoundFiles;
    }

    // --- RENDERING ---

    /**
     * Рендеринг списку завантажених файлів та оновлення контролів об'єднання.
     */
    function renderFileList() {
        const hasImages = uploadedFiles.some(isImage);
        const hasPdfs = uploadedFiles.some(isPdf);
        
        imageMergeControlsEl.style.display = hasImages ? 'flex' : 'none';
        pdfMergeControlsEl.style.display = hasPdfs ? 'flex' : 'none';

        const fileListHTML = uploadedFiles.map(file => {
            const isImg = isImage(file);
            const isPDF = isPdf(file);
            const isSelectable = isImg || isPDF; // Вибирається для об'єднання
            const isBound = Object.values(boundFiles).includes(file.id);
            const draggable = !isBound ? 'draggable="true"' : '';
            const opacity = isBound ? 'opacity-60 cursor-not-allowed' : 'cursor-grab';
            
            return `
                <div id="file-${file.id}" 
                    data-file-id="${file.id}" 
                    data-file-type="${isImg ? 'image' : (isPDF ? 'pdf' : 'other')}"
                    class="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg shadow-sm hover:bg-gray-100 ${opacity} transition duration-100"
                    ${draggable}
                    ondragstart="handleDragStart(event, ${file.id})"
                    ondragend="handleDragEnd(event)">
                    
                    <!-- Чекбокс тільки для зображень/PDF -->
                    ${isSelectable ? `<input type="checkbox" id="check-${file.id}" data-file-id="${file.id}" onchange="checkMergeControls()" class="w-4 h-4 text-orange-600 bg-gray-100 border-gray-300 rounded focus:ring-orange-500">` : '<span class="w-4 h-4"></span>'}
                    
                    ${getFileIcon(file.type)}
                    
                    <div class="flex-grow min-w-0">
                        <p class="text-sm font-medium text-gray-800 truncate" title="${file.name}">${file.name}</p>
                        <p class="text-xs text-gray-500">${(file.size / 1024 / 1024).toFixed(2)} MB</p>
                    </div>
                    
                    <button onclick="openPreviewModal(${file.id})" 
                            class="text-blue-500 hover:text-blue-700 text-sm font-medium transition duration-150">
                        Прев'ю
                    </button>
                    
                    <button onclick="removeFile(${file.id})" 
                            class="text-red-500 hover:text-red-700 transition duration-150 p-1 rounded">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                </div>
            `;
        }).join('');

        fileListEl.innerHTML = fileListHTML || '<p id="emptyMessage" class="text-gray-400 text-center py-10">Файли ще не завантажені.</p>';
        document.getElementById('fileCount').textContent = uploadedFiles.length;
        
        checkMergeControls();
        updateDownloadButtonState();
    }
    
    /**
     * Перевіряє стан чекбоксів і вмикає/вимикає кнопки об'єднання.
     */
    function checkMergeControls() {
        const checkboxes = Array.from(document.querySelectorAll('#fileList input[type="checkbox"]'));
        
        const selectedImages = checkboxes.filter(cb => cb.checked && uploadedFiles.find(f => f.id === parseInt(cb.dataset.fileId) && isImage(f)));
        const selectedPdfs = checkboxes.filter(cb => cb.checked && uploadedFiles.find(f => f.id === parseInt(cb.dataset.fileId) && isPdf(f)));
        
        // Змінено: Дозволити конвертацію 1+ зображень (Згідно з запитом 2)
        document.getElementById('imageMergeBtn').disabled = selectedImages.length < 1;
        document.getElementById('pdfMergeBtn').disabled = selectedPdfs.length < 2;
    }

    /**
     * Видаляє файл зі списку.
     * @param {number} fileId - ID файлу для видалення.
     */
    function removeFile(fileId) {
        uploadedFiles = uploadedFiles.filter(f => f.id !== fileId);
        
        // Remove any binding associated with this file
        Object.keys(boundFiles).forEach(key => {
            if (boundFiles[key] === fileId) {
                boundFiles[key] = null;
            }
        });
        
        renderBoundFields();
        renderFileList();
        showMessage('Файл успішно видалено.', 2000);
    }

    /**
     * Рендеринг прив'язаних полів.
     */
    function renderBoundFields() {
        ['manual', 'specs', 'certificate'].forEach(key => {
            const fieldEl = document.getElementById(`field_${key}`);
            const fileNameEl = document.getElementById(`${key}FileName`);
            const removeBtnEl = document.getElementById(`${key}RemoveBtn`);
            
            fieldEl.classList.remove('has-file');
            fileNameEl.textContent = '';
            removeBtnEl.classList.add('hidden');

            if (boundFiles[key]) {
                const file = uploadedFiles.find(f => f.id === boundFiles[key]);
                if (file) {
                    fieldEl.classList.add('has-file');
                    fileNameEl.textContent = `(Файл: ${file.name})`;
                    removeBtnEl.classList.remove('hidden');
                } else {
                    // File was deleted or merged, remove binding
                    boundFiles[key] = null;
                }
            }
        });
        renderFileList(); // Re-render file list to update drag state
    }

    // --- FILE UPLOAD LOGIC ---

    /**
     * Обробляє завантаження файлів через input.
     * @param {FileList} files - Список завантажених файлів.
     */
    function handleFileUpload(files) {
        Array.from(files).forEach(file => {
            uploadedFiles.push({
                id: nextFileId++,
                name: file.name,
                type: file.type || 'application/octet-stream', // Fallback type
                size: file.size,
                file: file, // Original File/Blob object
            });
        });
        renderFileList();
    }

    // --- DRAG-AND-DROP FOR UPLOAD ZONE ---
    function handleDragOver(e) {
        e.preventDefault();
        dropZoneEl.classList.add('drag-over');
    }

    function handleDragLeave(e) {
        e.preventDefault();
        dropZoneEl.classList.remove('drag-over');
    }

    function handleDrop(e) {
        e.preventDefault();
        dropZoneEl.classList.remove('drag-over');
        if (e.dataTransfer.files.length) {
            handleFileUpload(e.dataTransfer.files);
        }
    }

    // --- DRAG-AND-DROP FOR BINDING ---
    let draggedFileId = null;

    function handleDragStart(e, fileId) {
        draggedFileId = fileId;
        e.dataTransfer.setData('text/plain', fileId);
        // Візуальний ефект при перетягуванні
        e.currentTarget.classList.add('opacity-50', 'border-2', 'border-blue-500');
    }

    function handleDragEnd(e) {
        draggedFileId = null;
        // Прибираємо візуальний ефект
        e.currentTarget.classList.remove('opacity-50', 'border-2', 'border-blue-500');
    }

    function handleFieldDragOver(e) {
        e.preventDefault();
        e.currentTarget.classList.add('bg-blue-100', 'border-blue-500', 'border-solid');
    }

    function handleFieldDragLeave(e) {
        e.preventDefault();
        e.currentTarget.classList.remove('bg-blue-100', 'border-blue-500', 'border-solid');
    }

    function handleFieldDrop(e) {
        e.preventDefault();
        e.currentTarget.classList.remove('bg-blue-100', 'border-blue-500', 'border-solid');
        
        const fileId = draggedFileId; // Use the global state from dragstart
        const fieldKey = e.currentTarget.dataset.key;

        if (fileId && fieldKey) {
            // Unbind from previous field if this file was bound elsewhere
            for (const key in boundFiles) {
                if (boundFiles[key] === fileId) {
                    boundFiles[key] = null; 
                }
            }
            
            boundFiles[fieldKey] = parseInt(fileId);
            renderBoundFields();
            showMessage(`Файл прив'язано до поля "${e.currentTarget.dataset.label}".`, 2500);
        }
    }

    /**
     * Видаляє прив'язку файлу з певного поля.
     * @param {string} key - Ключ поля ('manual', 'specs', 'certificate').
     */
    function removeBoundFile(key) {
        const fieldEl = document.getElementById(`field_${key}`);
        const fieldLabel = fieldEl ? fieldEl.dataset.label : key;
        boundFiles[key] = null;
        renderBoundFields();
        showMessage(`Прив'язку видалено з поля "${fieldLabel}".`, 2500);
    }
    
    // --- PREVIEW LOGIC (Modal) ---
    
    /**
     * Рендерить PDF на Canvas, використовуючи pdf.js.
     * @param {Blob} pdfBlob - Blob об'єкт PDF.
     * @param {HTMLElement} containerEl - Елемент-контейнер для вставки Canvas.
     */
    async function renderPdfToCanvas(pdfBlob, containerEl) {
        containerEl.innerHTML = '<div class="text-center py-8"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-red-500 mx-auto"></div><p class="text-gray-600 mt-2">Завантаження PDF...</p></div>';
        
        if (!window.pdfjsLib) {
             containerEl.innerHTML = `<div class="text-center p-8 bg-gray-100 rounded-lg"><p class="text-lg font-medium text-red-700">Помилка: Бібліотека pdf.js не завантажена.</p></div>`;
             return;
        }

        const arrayBuffer = await pdfBlob.arrayBuffer();
        
        try {
            const pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            containerEl.innerHTML = ''; // Очищаємо завантажувач

            // Рендеримо кожну сторінку
            for (let i = 1; i <= pdfDocument.numPages; i++) {
                const page = await pdfDocument.getPage(i);
                
                // Визначаємо масштаб, щоб сторінка відповідала ширині модального вікна (max-w-4xl)
                // Модальне вікно max-w-4xl приблизно 896px. Використовуємо 850px для запасу.
                const viewport = page.getViewport({ scale: 1 });
                const desiredWidth = 850; 
                const scale = desiredWidth / viewport.width;
                const scaledViewport = page.getViewport({ scale: scale });

                // Створюємо елементи Canvas
                const canvas = document.createElement('canvas');
                const canvasContext = canvas.getContext('2d');
                canvas.height = scaledViewport.height;
                canvas.width = scaledViewport.width;
                canvas.className = 'my-4 border border-gray-200 rounded-lg shadow-md'; // Додаємо стилі до самого Canvas

                // Створюємо div-контейнер для сторінки (для підпису та маргінів)
                const pageContainer = document.createElement('div');
                // Видалено items-center, оскільки це робить батьківський контейнер #previewContent
                pageContainer.className = 'flex flex-col mb-6 w-full'; 
                pageContainer.innerHTML = `<p class="text-xs text-gray-500 mb-1 text-center">Сторінка ${i}</p>`;
                pageContainer.appendChild(canvas);
                
                containerEl.appendChild(pageContainer);

                // Рендеримо сторінку на Canvas
                const renderContext = {
                    canvasContext,
                    viewport: scaledViewport
                };
                await page.render(renderContext).promise;
            }
            
        } catch (error) {
            console.error("Помилка рендерингу PDF:", error);
            containerEl.innerHTML = `<div class="text-center p-8 bg-red-50 rounded-lg"><p class="text-lg font-medium text-red-700">Не вдалося відобразити PDF.</p><p class="text-sm text-gray-500 mt-2">Деталі: ${error.message}</p></div>`;
        }
    }

    /**
     * Відкриває модальне вікно попереднього перегляду.
     * @param {number} fileId - ID файлу.
     */
    function openPreviewModal(fileId) {
        const file = uploadedFiles.find(f => f.id === fileId);
        if (!file) return showMessage('Помилка: Файл не знайдено.', 3000);

        document.getElementById('previewTitle').textContent = `Попередній перегляд: ${file.name}`;
        const contentEl = document.getElementById('previewContent');
        contentEl.innerHTML = '';
        
        if (!file.file) {
            contentEl.innerHTML = `<div class="text-center p-8 bg-gray-100 rounded-lg"><p class="text-lg font-medium text-gray-700">Помилка: Відсутні дані файлу.</p></div>`;
        } else if (isImage(file)) {
            // Show image directly
            const imgUrl = URL.createObjectURL(file.file);
            // Використовуємо max-w-full для адаптивності зображення
            contentEl.innerHTML = `<img src="${imgUrl}" alt="${file.name}" class="max-w-full h-auto rounded-lg" onerror="this.onerror=null; this.src='https://placehold.co/400x300/e0e0e0/333?text=Помилка+завантаження+зображення';">`;
        } else if (isPdf(file)) {
            // Use PDF.js to render PDF to canvas
            renderPdfToCanvas(file.file, contentEl);
        } else {
            // Simple info for non-image/non-pdf files
            contentEl.innerHTML = `
                <div class="text-center p-8 bg-gray-100 rounded-lg">
                    <p class="text-lg font-medium text-gray-700">Попередній перегляд не підтримується для цього формату.</p>
                    <p class="text-sm text-gray-500 mt-2">Тип файлу: ${file.type}</p>
                    <p class="text-sm text-gray-500">Розмір: ${(file.size / 1024 / 1024).toFixed(2)} MB</p>
                </div>
            `;
        }

        previewModalEl.classList.remove('hidden');
        previewModalEl.classList.add('flex');
    }

    /**
     * Закриває модальне вікно попереднього перегляду.
     */
    function closePreviewModal() {
        previewModalEl.classList.add('hidden');
        previewModalEl.classList.remove('flex');
        
        // Очищаємо вміст
        const contentEl = document.getElementById('previewContent');
        
        // Відкликаємо Object URL для зображень, якщо вони використовувалися
        const img = contentEl.querySelector('img');
        if (img && img.src.startsWith('blob:')) URL.revokeObjectURL(img.src);
        
        contentEl.innerHTML = ''; 
    }
    
    // --- CONVERSION & MERGE LOGIC ---

    /**
     * Об'єднує вибрані PDF-файли в один.
     */
    async function handlePdfMerge() {
        if (!window.PDFLib) return showMessage('Помилка: Бібліотека PDFLib не завантажена.', 5000);
        
        const selectedPdfIds = Array.from(document.querySelectorAll('#fileList input[type="checkbox"]'))
            .filter(cb => cb.checked && uploadedFiles.find(f => f.id === parseInt(cb.dataset.fileId) && isPdf(f)))
            .map(cb => parseInt(cb.dataset.fileId));
            
        if (selectedPdfIds.length < 2) {
            showMessage('Будь ласка, виберіть мінімум два PDF-файли для об\'єднання.', 4000);
            return;
        }

        const pdfsToMerge = selectedPdfIds.map(id => uploadedFiles.find(f => f.id === id)).filter(Boolean);

        const newPdfDoc = await PDFLib.PDFDocument.create();
        let mergeSuccess = true;

        const originalBtnText = document.getElementById('pdfMergeBtn').textContent;
        document.getElementById('pdfMergeBtn').textContent = 'Обробка...';
        document.getElementById('pdfMergeBtn').disabled = true;

        for (const file of pdfsToMerge) {
            try {
                // Читаємо Blob як ArrayBuffer
                const pdfBytes = await file.file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                
                // Копіюємо всі сторінки з поточного PDF в новий документ
                const copiedPages = await newPdfDoc.copyPages(pdfDoc, pdfDoc.getPageIndices());
                copiedPages.forEach((page) => newPdfDoc.addPage(page));

            } catch (error) {
                console.error("Помилка при обробці PDF:", file.name, error);
                mergeSuccess = false;
                showMessage(`Помилка при обробці файлу ${file.name}. Об'єднання скасовано.`, 6000);
                break;
            }
        }
        
        document.getElementById('pdfMergeBtn').textContent = originalBtnText;
        document.getElementById('pdfMergeBtn').disabled = false; // Will be re-enabled by checkMergeControls if conditions met

        if (!mergeSuccess) return;
        
        // Серіалізуємо новий PDF
        const mergedPdfBytes = await newPdfDoc.save();
        const mergedPdfBlob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
        
        // Визначаємо назву та додаємо новий файл
        const newFileName = `merged_${new Date().toISOString().slice(0, 10)}.pdf`;
        
        uploadedFiles.push({
            id: nextFileId++,
            name: newFileName,
            type: 'application/pdf',
            size: mergedPdfBlob.size,
            file: mergedPdfBlob, // Blob object
        });

        // Видаляємо об'єднані файли
        uploadedFiles = uploadedFiles.filter(f => !selectedPdfIds.includes(f.id));
        
        // Перевіряємо, чи не були видалені файли прив'язані до полів
        Object.keys(boundFiles).forEach(key => {
            if (selectedPdfIds.includes(boundFiles[key])) {
                boundFiles[key] = null;
            }
        });

        renderBoundFields();
        renderFileList();
        showMessage(`Успішно об'єднано ${selectedPdfIds.length} PDF-файлів у ${newFileName}!`, 5000);
    }

    /**
     * Конвертує вибрані зображення (1+) у PDF-файл.
     */
    async function handleImageMerge() {
        if (!window.jspdf) return showMessage('Помилка: Бібліотека jspdf не завантажена.', 5000);

        const selectedImageIds = Array.from(document.querySelectorAll('#fileList input[type="checkbox"]'))
            .filter(cb => cb.checked && uploadedFiles.find(f => f.id === parseInt(cb.dataset.fileId) && isImage(f)))
            .map(cb => parseInt(cb.dataset.fileId));
        
        // Змінено: Дозволити конвертацію 1+ зображень (Згідно з запитом 2)
        if (selectedImageIds.length < 1) {
            showMessage('Будь ласка, виберіть мінімум одне зображення для конвертації.', 4000);
            return;
        }

        const imagesToConvert = selectedImageIds.map(id => uploadedFiles.find(f => f.id === id)).filter(Boolean);

        const originalBtnText = document.getElementById('imageMergeBtn').textContent;
        document.getElementById('imageMergeBtn').textContent = 'Обробка...';
        document.getElementById('imageMergeBtn').disabled = true;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();
        pdf.deletePage(1); // Видаляємо порожню першу сторінку

        let conversionSuccess = true;

        for (let i = 0; i < imagesToConvert.length; i++) {
            const file = imagesToConvert[i];
            
            try {
                const imgData = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file.file);
                });

                // Створюємо тимчасовий елемент img для отримання розмірів
                const img = new Image();
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.src = imgData;
                });

                const imgWidth = img.width;
                const imgHeight = img.height;
                const format = imgData.split(';')[0].split('/')[1] || 'jpeg';
                
                // Стандартні розміри A4 в одиницях jsPDF (pt): 595.28 x 841.89
                const pdfWidth = 595.28; 
                let pdfHeight = (imgHeight * pdfWidth) / imgWidth;

                // Додаємо нову сторінку з розмірами зображення
                pdf.addPage([pdfWidth, pdfHeight], pdfWidth > pdfHeight ? 'l' : 'p'); 

                // Додаємо зображення, яке розтягується на всю сторінку
                pdf.addImage(imgData, format, 0, 0, pdfWidth, pdfHeight);

            } catch (error) {
                console.error("Помилка конвертації зображення:", file.name, error);
                conversionSuccess = false;
                showMessage(`Помилка при обробці файлу ${file.name}. Конвертація скасована.`, 6000);
                break;
            }
        }
        
        document.getElementById('imageMergeBtn').textContent = originalBtnText;
        document.getElementById('imageMergeBtn').disabled = false; // Will be re-enabled by checkMergeControls if conditions met

        if (!conversionSuccess) return;

        // Зберігаємо PDF як Blob
        const pdfBlob = pdf.output('blob');

        // Визначаємо назву та додаємо новий файл
        const newFileName = `images_${new Date().toISOString().slice(0, 10)}.pdf`;
        
        uploadedFiles.push({
            id: nextFileId++,
            name: newFileName,
            type: 'application/pdf',
            size: pdfBlob.size,
            file: pdfBlob, // Blob object
        });

        // Видаляємо об'єднані файли
        uploadedFiles = uploadedFiles.filter(f => !selectedImageIds.includes(f.id));
        
        // Перевіряємо, чи не були видалені файли прив'язані до полів
        Object.keys(boundFiles).forEach(key => {
            if (selectedImageIds.includes(boundFiles[key])) {
                boundFiles[key] = null;
            }
        });

        renderBoundFields();
        renderFileList();
        showMessage(`Успішно конвертовано/об'єднано ${selectedImageIds.length} зображень у ${newFileName}!`, 5000);
    }
    
    // --- ZIP DOWNLOAD LOGIC ---

    /**
     * Створює і завантажує ZIP-архів з прив'язаними файлами.
     */
    async function handleZipDownload() {
        if (!window.JSZip) return showMessage('Помилка: Бібліотека JSZip не завантажена.', 5000);

        const internalCode = document.getElementById('internalCode').value.trim();
        if (!internalCode) {
            return showMessage('Будь ласка, введіть Внутрішній код.', 3000);
        }

        const filesToZip = [];
        let missingFile = false;

        const fieldMap = {
            'manual': 'Інструкція',
            'specs': 'Технічні характеристики',
            'certificate': 'Сертифікат'
        };

        // Збираємо файли
        Object.keys(boundFiles).forEach(key => {
            const fileId = boundFiles[key];
            if (fileId) {
                const file = uploadedFiles.find(f => f.id === fileId);
                if (file) {
                    // Формуємо ім'я файлу згідно з шаблоном
                    const originalExt = file.name.split('.').pop();
                    const newFileName = `${internalCode}-${key}-${fieldMap[key]}.${originalExt}`
                                            .toLowerCase()
                                            .replace(/[^a-z0-9\-\.]/g, '_') // Замінюємо пробіли та кирилицю на _
                                            .replace(/__+/g, '_'); // Прибираємо подвійні підкреслення
                    
                    filesToZip.push({ 
                        file: file.file, 
                        name: newFileName 
                    });
                } else {
                    missingFile = true;
                    console.error(`Bound file ID ${fileId} not found in uploadedFiles.`);
                }
            }
        });

        if (missingFile) {
            return showMessage('Помилка: Не вдалося знайти один або кілька прив\'язаних файлів.', 5000);
        }

        if (filesToZip.length === 0) {
            return showMessage('Немає прив\'язаних файлів для завантаження.', 3000);
        }

        const zip = new JSZip();
        filesToZip.forEach(item => {
            zip.file(item.name, item.file);
        });

        document.getElementById('downloadText').textContent = 'Створення ZIP...';
        downloadZipBtn.disabled = true;

        try {
            const zipBlob = await zip.generateAsync({ type: "blob" });
            
            // Створюємо URL та ініціюємо завантаження
            const zipFileName = `${internalCode}_package.zip`;
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = zipFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessage(`ZIP-архів ${zipFileName} успішно створено та завантажено.`, 5000);

        } catch (error) {
            console.error("Помилка створення ZIP:", error);
            showMessage('Помилка: Не вдалося створити ZIP-архів.', 5000);
        } finally {
            document.getElementById('downloadText').textContent = 'Завантажити ZIP';
            updateDownloadButtonState();
        }
    }


    /**
     * Очищає всі дані (файли, прив'язки, код).
     */
    function handleClearAll() {
        uploadedFiles = [];
        boundFiles = {};
        nextFileId = 1;
        document.getElementById('internalCode').value = '';
        
        renderBoundFields();
        renderFileList();
        
        // Uncheck all checkboxes
        Array.from(document.querySelectorAll('#fileList input[type="checkbox"]')).forEach(cb => cb.checked = false);
        checkMergeControls();
        
        showMessage('Усі дані очищено.', 3000);
    }

    // --- INITIALIZATION ---

    document.addEventListener('DOMContentLoaded', () => {
        // Ініціалізація полів прив'язки
        boundFiles = {
            'manual': null,
            'specs': null,
            'certificate': null,
        };
        renderFileList();
        renderBoundFields();
    });
</script>
</body>
</html>
